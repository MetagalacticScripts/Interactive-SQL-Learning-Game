<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <title>SQL Candy Quest üç≠</title>
  <script src="https://cdn.jsdelivr.net/npm/canvas-confetti@1.6.0/dist/confetti.browser.min.js"></script>
  <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@400;500&display=swap" rel="stylesheet">
  <style>
    html, body {
      margin: 0;
      padding: 0;
      height: 100%;
      background: linear-gradient(to bottom, #E6F0FA, #EAF7F0);
      font-family: 'Roboto', sans-serif;
      color: #333;
      overflow-x: hidden;
      overflow-y: auto;
    }
    .container {
      display: flex;
      flex-direction: column;
      min-height: 100vh;
      box-sizing: border-box;
    }
    .sidebar {
      width: 100%;
      background: #FFFFFF;
      border-top: 1px solid #E0E0E0;
      padding: 2vh;
      box-sizing: border-box;
      box-shadow: 0 -2px 5px rgba(0, 0, 0, 0.05);
      order: 2;
      overflow-y: auto;
      max-height: 40vh;
    }
    .main-content {
      flex: 1;
      display: flex;
      flex-direction: column;
      align-items: center;
      padding: 2vh;
      box-sizing: border-box;
      order: 1;
      overflow-y: auto;
    }
    h2, h3 {
      margin: 1vh 0;
      color: #4A90E2;
      font-weight: 500;
      font-size: clamp(1.5rem, 5vw, 2rem);
    }
    .time-display {
      font-size: clamp(1rem, 4vw, 1.5rem);
      margin: 1vh 0;
      color: #4A90E2;
    }
    #scoreboard {
      margin-top: 2vh;
      border: 1px solid #E0E0E0;
      border-radius: 1vh;
      padding: 1vh;
      background: #FAFAFA;
      box-shadow: 0 0.2vh 1vh rgba(0, 0, 0, 0.05);
    }
    #score-list {
      list-style: none;
      margin: 0;
      padding: 0;
    }
    #score-list li {
      padding: 0.5vh 0;
      border-bottom: 1px solid #E0E0E0;
      font-size: clamp(0.8rem, 3vw, 1.2rem);
    }
    h1 {
      font-size: clamp(2rem, 8vw, 3rem);
      color: #4A90E2;
      margin: 2vh 0;
      padding: 1vh;
      font-weight: 500;
    }
    .character-select button, .controls button {
      background: #4A90E2;
      color: #FFFFFF;
      border: none;
      padding: clamp(0.5vh, 1vh, 1rem) clamp(1.5vw, 3vw, 2rem);
      margin: 0.5vh;
      border-radius: 0.5vh;
      cursor: pointer;
      font-size: clamp(1rem, 3.5vw, 1.2rem);
      transition: background 0.3s ease, transform 0.2s ease;
      box-shadow: 0 0.2vh 0.6vh rgba(0, 0, 0, 0.1);
    }
    .character-select button:hover, .controls button:hover {
      background: #357ABD;
      transform: scale(1.1);
    }
    #hints-left {
      font-size: clamp(1rem, 3.5vw, 1.2rem);
      color: #4A90E2;
      margin: 0.5vh 0;
    }
    .board {
      width: clamp(80vw, 90vw, 70vw);
      height: clamp(40vh, 50vh, 80vh);
      background: #FFFFFF;
      margin: 1vh 0;
      border-radius: 1vh;
      box-shadow: 0 0.4vh 2vh rgba(0, 0, 0, 0.1);
      position: relative;
      border: 1px solid #E0E0E0;
      overflow: hidden;
    }
    @media (min-width: 768px) {
      .board {
        overflow-y: auto; /* Keep scrollbar for desktop */
      }
    }
    .progress-bar {
      width: clamp(80vw, 90vw, 70vw);
      height: 1.5vh;
      background: #E0E0E0;
      border-radius: 0.5vh;
      margin: 0.5vh 0;
    }
    #progress {
      height: 100%;
      background: linear-gradient(to right, #B3E5FC, #B2DFDB, #B2F0B2);
      border-radius: 0.5vh;
      transition: width 0.5s ease;
    }
    .tiles {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(50px, 1fr));
      gap: 0.5vh;
      width: 100%;
      height: 100%;
      padding: 1vh;
      box-sizing: border-box;
    }
    @media (min-width: 768px) {
      .tiles {
        grid-template-columns: repeat(5, 1fr); /* 5x4 grid on desktop */
        grid-template-rows: repeat(4, 1fr);
      }
    }
    .tile {
      border-radius: 0.5vh;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: clamp(1.5rem, 5vw, 2rem);
      font-weight: bold;
      color: #333;
      box-shadow: 0 0.2vh 0.6vh rgba(0, 0, 0, 0.1);
      transition: transform 0.2s ease;
      background: #F0F4FF;
      aspect-ratio: 1 / 1;
    }
    .tile:hover {
      transform: translateY(-0.3vh);
      box-shadow: 0 0.6vh 1.2vh rgba(240, 244, 255, 0.3);
    }
    .start-tile {
      background: #FFD700;
      color: #333;
      font-size: clamp(1.2rem, 4vw, 1.5rem);
      border: 1px solid rgba(255, 215, 0, 0.5);
    }
    .sticky-tile {
      background: #FFA500;
      font-size: clamp(1.8rem, 6vw, 2.5rem);
      border: 1px solid rgba(255, 165, 0, 0.5);
    }
    .castle-icon {
      font-size: clamp(2rem, 7vw, 3rem);
    }
    .active-tile {
      box-shadow: 0 0 1.5vh #4A90E2, 0 0 3vh #357ABD;
    }
    #player {
      font-size: clamp(3rem, 7vw, 5rem);
      position: absolute;
      transition: left 0.5s ease-in-out, top 0.5s ease-in-out, transform 0.5s ease-out;
      z-index: 10;
    }
    #player.move {
      transform: scale(1.1);
    }
    .popup {
      display: none;
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: #FFFFFF;
      border-radius: 1vh;
      padding: 2vh;
      width: clamp(70vw, 80vw, 50vw);
      max-width: 600px;
      box-shadow: 0 1vh 4vh rgba(0, 0, 0, 0.2);
      z-index: 1000;
      animation: popIn 0.3s ease-out;
      overflow-y: auto;
      max-height: 80vh;
    }
    @keyframes popIn {
      from { transform: translate(-50%, -50%) scale(0.8); opacity: 0; }
      to { transform: translate(-50%, -50%) scale(1); opacity: 1; }
    }
    .popup-content {
      background: #FAFAFA;
      border: 1px solid #E0E0E0;
      padding: 1.5vh;
      border-radius: 0.5vh;
      position: relative;
      overflow-x: hidden;
    }
    .popup h2 {
      color: #4A90E2;
      font-size: clamp(1.5rem, 5vw, 1.5rem);
      margin-bottom: 1vh;
      font-weight: 500;
    }
    #answer {
      width: 90%;
      min-height: 15vh;
      padding: 1vh;
      margin: 1vh 0;
      border: 1px solid #E0E0E0;
      border-radius: 0.5vh;
      font-size: clamp(0.8rem, 3vw, 1rem);
      font-family: 'Courier New', monospace;
      background: #FFFFFF;
      outline: none;
      overflow-y: auto;
      user-select: text;
      direction: ltr;
      white-space: pre-wrap;
      word-wrap: break-word;
      max-height: 20vh; /* Limit height to prevent overflow */
      overflow-y: auto; /* Add scrollbar if content exceeds */
    }
    #answer[contenteditable]:empty:before {
      content: attr(placeholder);
      color: #aaa;
    }
    .popup-buttons button {
      background: #4A90E2;
      color: #FFFFFF;
      border: none;
      padding: clamp(0.5vh, 1vh, 1rem) clamp(1vw, 2vw, 1rem);
      margin: 0.5vh;
      border-radius: 0.5vh;
      cursor: pointer;
      font-size: clamp(0.8rem, 3vw, 1rem);
      transition: background 0.3s;
    }
    .popup-buttons button:hover {
      background: #357ABD;
    }
    .close-button {
      position: absolute;
      top: 1vh;
      right: 1.5vh;
      background: transparent;
      border: none;
      font-size: clamp(1rem, 4vw, 1.5rem);
      cursor: pointer;
      color: #888;
      transition: color 0.3s;
    }
    .close-button:hover {
      color: #4A90E2;
    }
    #message-popup .popup-content p {
      margin: 0;
      padding: 1vh 0;
      color: #555;
      white-space: pre-wrap;
      font-size: clamp(0.8rem, 3vw, 1rem);
    }
    #final-popup .popup-content {
      text-align: center;
    }
    #final-popup .confetti {
      font-size: clamp(1.5rem, 6vw, 2rem);
      margin-bottom: 1vh;
    }
    #final-popup input {
      width: 80%;
      padding: 1vh;
      margin: 1vh 0;
      border: 1px solid #E0E0E0;
      border-radius: 0.5vh;
      font-size: clamp(0.8rem, 3vw, 1rem);
    }
    @media (min-width: 768px) {
      .container {
        flex-direction: row-reverse;
      }
      .sidebar {
        width: 25vw;
        border-top: none;
        border-left: 1px solid #E0E0E0;
        box-shadow: -2px 0 5px rgba(0, 0, 0, 0.05);
        max-height: none;
        order: 0;
      }
      .main-content {
        order: 0;
      }
      .board {
        width: 70vw;
        height: 80vh; /* Fixed height with scroll */
      }
      .progress-bar {
        width: 70vw;
      }
      .tiles {
        grid-template-columns: repeat(5, 1fr); /* 5x4 grid on desktop */
        grid-template-rows: repeat(4, 1fr);
      }
      .tile {
        font-size: clamp(2rem, 5vw, 3rem);
      }
      .start-tile {
        font-size: clamp(1.5rem, 4vw, 2rem);
      }
      .sticky-tile {
        font-size: clamp(2rem, 6vw, 3rem);
      }
      .castle-icon {
        font-size: clamp(3rem, 9vw, 4rem);
      }
      .controls {
        flex-wrap: nowrap;
      }
    }
    .sql-keyword {
      color: #C71585;
      font-weight: bold;
    }
    .sql-string {
      color: #32CD32;
    }
    .sql-number {
      color: #FF4500;
    }
  </style>
</head>
<body>
  <div class="container">
    <div class="main-content">
      <h1>Reach the Candy Castle!</h1>
      <div class="character-select">
        <button onclick="selectCharacter('üç≠')">Lollipop</button>
        <button onclick="selectCharacter('üç¨')">Candy</button>
        <button onclick="selectCharacter('üç´')">Chocolate</button>
      </div>
      <div class="board">
        <div id="tiles-container" class="tiles"></div>
        <div id="player">üç≠</div>
      </div>
      <div class="progress-bar"><div id="progress" style="width: 0%;"></div></div>
      <div class="controls">
        <button onclick="getQuestion('easy')">Easy Path</button>
        <button onclick="getQuestion('medium')">Medium Path</button>
        <button onclick="getQuestion('advanced')">Advanced Path</button>
        <button onclick="resetPlayer()">Reset</button>
      </div>
      <div id="hints-left">Hints Left: 3</div>
    </div>
    <div class="sidebar">
      <h2>SQL Candy Quest üç≠</h2>
      <div class="time-display" id="time-display">Time Elapsed: 0m 0s</div>
      <div id="scoreboard">
        <h3>Scoreboard</h3>
        <ul id="score-list"></ul>
      </div>
    </div>
  </div>
  <div id="question-popup" class="popup">
    <div class="popup-content">
      <button class="close-button" onclick="closePopup()">√ó</button>
      <h2>Sweet Challenge üç¨</h2>
      <p id="question-text"></p>
      <div id="answer" contenteditable="true" placeholder="Type your SQL query here..."></div>
      <div class="popup-buttons">
        <button onclick="submitAnswer()">Submit</button>
        <button onclick="showHint()">Hint</button>
        <button onclick="showDatabaseSchema()">Show Database Schema</button>
        <button onclick="showAnswer()">Show Answer</button>
      </div>
    </div>
  </div>
  <div id="message-popup" class="popup">
    <div class="popup-content">
      <button class="close-button" onclick="closeMessagePopup()">√ó</button>
      <p id="message-text"></p>
      <div class="popup-buttons">
        <button onclick="closeMessagePopup()">OK</button>
      </div>
    </div>
  </div>
  <div id="final-popup" class="popup">
    <div class="popup-content">
      <button class="close-button" onclick="closeFinalPopup()">√ó</button>
      <div class="confetti">üéâüéäüéâüéä</div>
      <p id="final-message"></p>
      <input type="text" id="player-name" placeholder="Enter your name">
      <div class="popup-buttons">
        <button onclick="submitFinalScore()">Submit</button>
      </div>
    </div>
  </div>
  <audio id="sticky-sound" preload="auto">
    <source src="data:audio/mpeg;base64,/+MYxAAAAANIAAAAAExBTUUzLjk4LjIA/+MYxDsAAABmQkVHSU4AAyAAAAAAR0lYQVQAAAAA/+MYxB8AAABQTEFZRQAAV2VsY29tZSB0byB0aGUgU29mdHdhcmUgRW5naW5lZXJpbmcgSW5zdGl0dXRlIQAA/+MYxCYAAADQTUVESVRBVElPTgAATWV0YWRhdGEgZm9yIHRoZSBTb2Z0d2FyZSBFbmdpbmVlcmluZyBJbnN0aXR1dGUAAAD/+MYxAwAAAExBTUUzAA==" type="audio/mpeg">
  </audio>
  <audio id="win-sound" preload="auto">
    <source src="data:audio/mpeg;base64,/+MYxAAAAANIAAAAAExBTUUzLjk4LjIA/+MYxDsAAABmQkVHSU4AAyAAAAAAR0lYQVQAAAAA/+MYxB8AAABQTEFZRQAAV2lubmluZyBzb3VuZCBmb3IgdGhlIFNvZnR3YXJlIEVuZ2luZWVyaW5nIEluc3RpdHV0ZQAA/+MYxCYAAADQTUVESVRBVElPTgAATWV0YWRhdGEgZm9yIHRoZSBTb2Z0d2FyZSBFbmdpbmVlcmluZyBJbnN0aXR1dGUAAAD/+MYxAwAAAExBTUUzAA==" type="audio/mpeg">
  </audio>
  <script>
    const totalSpaces = 20;
    let playerPosition = 0;
    let hintsLeft = 3;
    let playerIcon = "üç≠";
    let currentQuestion = null;
    let spacesToMove = 1;
    let moveCount = 0;
    let startTime = null;
    let timeInterval = null;
    const scoreboard = [];
    let tilePositions = [];
    const stickyTiles = new Set();
    let stickyAnswersNeeded = 0;
    let currentDifficulty = 'easy';
    const pastelColors = [
      '#F8C8DC', '#B3E5FC', '#D4A5E5', '#C8E6C9', '#FFD1B3',
      '#E6C9F0', '#A3D8F4', '#F5C6CB', '#B2F0B2', '#FFF5B7'
    ];
    const candyIcons = ['üç¨', 'üç´', 'üç≠', 'üç∞', 'üç™', 'üç©', 'üßÅ', 'üçÆ', 'üç¶'];

  const sqlQuestions = {
  easy: [
    // 1.
    {
      question: "Select all candy shops.",
      answer: "SELECT * FROM candy_shops;",
      result: {
        columns: ["shop_id", "shop_name", "location", "rating"],
        rows: [
          { shop_id: 1, shop_name: "Candy Haven", location: "Candyland", rating: 4.5 },
          { shop_id: 2, shop_name: "Sugar Delight", location: "Sugarville", rating: 3.8 },
          { shop_id: 3, shop_name: "Choco Bliss", location: "Choco Land", rating: 4.9 },
          { shop_id: 4, shop_name: "Gummy World", location: "Gummyville", rating: 3.2 },
          { shop_id: 5, shop_name: "Sweet Shop", location: "Sweet Town", rating: 4.0 }
        ]
      }
    },
    // 2.
    {
      question: "Select all products.",
      answer: "SELECT * FROM products;",
      result: {
        columns: ["product_id", "product_name", "category", "price", "stock_quantity"],
        rows: [
          { product_id: 1, product_name: "Lollipop", category: "Lollipop", price: 1.50, stock_quantity: 150 },
          { product_id: 2, product_name: "Chocolate Bar", category: "Chocolate", price: 2.00, stock_quantity: 200 },
          { product_id: 3, product_name: "Gummy Bears", category: "Gummy", price: 0.75, stock_quantity: 300 },
          { product_id: 4, product_name: "Hard Candy", category: "Hard Candy", price: 0.50, stock_quantity: 100 },
          { product_id: 5, product_name: "Caramel Chew", category: "Caramel", price: 1.25, stock_quantity: 75 }
        ]
      }
    },
    // 3.
    {
      question: "Select all sales records.",
      answer: "SELECT * FROM sales;",
      result: {
        columns: ["sale_id", "shop_id", "product_id", "sale_date", "quantity_sold", "total_amount"],
        rows: [
          { sale_id: 1, shop_id: 1, product_id: 1, sale_date: "2025-03-01", quantity_sold: 10, total_amount: 15.00 },
          { sale_id: 2, shop_id: 2, product_id: 2, sale_date: "2025-03-02", quantity_sold: 15, total_amount: 30.00 },
          { sale_id: 3, shop_id: 3, product_id: 3, sale_date: "2025-03-03", quantity_sold: 20, total_amount: 15.00 },
          { sale_id: 4, shop_id: 1, product_id: 4, sale_date: "2025-03-04", quantity_sold: 50, total_amount: 25.00 },
          { sale_id: 5, shop_id: 4, product_id: 5, sale_date: "2025-03-05", quantity_sold: 30, total_amount: 37.50 }
        ]
      }
    },
    // 4.
    {
      question: "Find candy shops in Candyland.",
      answer: "SELECT * FROM candy_shops WHERE location = 'Candyland';",
      result: {
        columns: ["shop_id", "shop_name", "location", "rating"],
        rows: [
          { shop_id: 1, shop_name: "Candy Haven", location: "Candyland", rating: 4.5 }
        ]
      }
    },
    // 5.
    {
      question: "Find candy shops in Sugarville.",
      answer: "SELECT * FROM candy_shops WHERE location = 'Sugarville';",
      result: {
        columns: ["shop_id", "shop_name", "location", "rating"],
        rows: [
          { shop_id: 2, shop_name: "Sugar Delight", location: "Sugarville", rating: 3.8 }
        ]
      }
    },
    // 6.
    {
      question: "Select products with price less than 2.",
      answer: "SELECT * FROM products WHERE price < 2;",
      result: {
        columns: ["product_id", "product_name", "category", "price", "stock_quantity"],
        rows: [
          { product_id: 1, product_name: "Lollipop", category: "Lollipop", price: 1.50, stock_quantity: 150 },
          { product_id: 3, product_name: "Gummy Bears", category: "Gummy", price: 0.75, stock_quantity: 300 },
          { product_id: 4, product_name: "Hard Candy", category: "Hard Candy", price: 0.50, stock_quantity: 100 },
          { product_id: 5, product_name: "Caramel Chew", category: "Caramel", price: 1.25, stock_quantity: 75 }
        ]
      }
    },
    // 7.
    {
      question: "Select products with stock_quantity greater than 100.",
      answer: "SELECT * FROM products WHERE stock_quantity > 100;",
      result: {
        columns: ["product_id", "product_name", "category", "price", "stock_quantity"],
        rows: [
          { product_id: 1, product_name: "Lollipop", category: "Lollipop", price: 1.50, stock_quantity: 150 },
          { product_id: 2, product_name: "Chocolate Bar", category: "Chocolate", price: 2.00, stock_quantity: 200 },
          { product_id: 3, product_name: "Gummy Bears", category: "Gummy", price: 0.75, stock_quantity: 300 }
        ]
      }
    },
    // 8.
    {
      question: "Select sales on 2025-03-01.",
      answer: "SELECT * FROM sales WHERE sale_date = '2025-03-01';",
      result: {
        columns: ["sale_id", "shop_id", "product_id", "sale_date", "quantity_sold", "total_amount"],
        rows: [
          { sale_id: 1, shop_id: 1, product_id: 1, sale_date: "2025-03-01", quantity_sold: 10, total_amount: 15.00 }
        ]
      }
    },
    // 9.
    {
      question: "Select products with price equal to 2.00.",
      answer: "SELECT * FROM products WHERE price = 2.00;",
      result: {
        columns: ["product_id", "product_name", "category", "price", "stock_quantity"],
        rows: [
          { product_id: 2, product_name: "Chocolate Bar", category: "Chocolate", price: 2.00, stock_quantity: 200 }
        ]
      }
    },
    // 10.
    {
      question: "Select products in the Chocolate category.",
      answer: "SELECT * FROM products WHERE category = 'Chocolate';",
      result: {
        columns: ["product_id", "product_name", "category", "price", "stock_quantity"],
        rows: [
          { product_id: 2, product_name: "Chocolate Bar", category: "Chocolate", price: 2.00, stock_quantity: 200 }
        ]
      }
    },
    // 11.
    {
      question: "Select sales with quantity_sold equal to 15.",
      answer: "SELECT * FROM sales WHERE quantity_sold = 15;",
      result: {
        columns: ["sale_id", "shop_id", "product_id", "sale_date", "quantity_sold", "total_amount"],
        rows: [
          { sale_id: 2, shop_id: 2, product_id: 2, sale_date: "2025-03-02", quantity_sold: 15, total_amount: 30.00 }
        ]
      }
    },
    // 12.
    {
      question: "Select product names from products.",
      answer: "SELECT product_name FROM products;",
      result: {
        columns: ["product_name"],
        rows: [
          { product_name: "Lollipop" },
          { product_name: "Chocolate Bar" },
          { product_name: "Gummy Bears" },
          { product_name: "Hard Candy" },
          { product_name: "Caramel Chew" }
        ]
      }
    },
    // 13.
    {
      question: "Select candy shop names from candy_shops.",
      answer: "SELECT shop_name FROM candy_shops;",
      result: {
        columns: ["shop_name"],
        rows: [
          { shop_name: "Candy Haven" },
          { shop_name: "Sugar Delight" },
          { shop_name: "Choco Bliss" },
          { shop_name: "Gummy World" },
          { shop_name: "Sweet Shop" }
        ]
      }
    },
    // 14.
    {
      question: "Select sale dates from sales.",
      answer: "SELECT sale_date FROM sales;",
      result: {
        columns: ["sale_date"],
        rows: [
          { sale_date: "2025-03-01" },
          { sale_date: "2025-03-02" },
          { sale_date: "2025-03-03" },
          { sale_date: "2025-03-04" },
          { sale_date: "2025-03-05" }
        ]
      }
    },
    // 15.
    {
      question: "Select candy shop names ordered by shop_name ASC.",
      answer: "SELECT * FROM candy_shops ORDER BY shop_name ASC;",
      result: {
        columns: ["shop_id", "shop_name", "location", "rating"],
        rows: [
          { shop_id: 1, shop_name: "Candy Haven", location: "Candyland", rating: 4.5 },
          { shop_id: 3, shop_name: "Choco Bliss", location: "Choco Land", rating: 4.9 },
          { shop_id: 4, shop_name: "Gummy World", location: "Gummyville", rating: 3.2 },
          { shop_id: 5, shop_name: "Sweet Shop", location: "Sweet Town", rating: 4.0 },
          { shop_id: 2, shop_name: "Sugar Delight", location: "Sugarville", rating: 3.8 }
        ]
      }
    },
    // 16.
    {
      question: "Select products ordered by product_name DESC.",
      answer: "SELECT product_name FROM products ORDER BY product_name DESC;",
      result: {
        columns: ["product_name"],
        rows: [
          { product_name: "Lollipop" },
          { product_name: "Hard Candy" },
          { product_name: "Gummy Bears" },
          { product_name: "Chocolate Bar" },
          { product_name: "Caramel Chew" }
        ]
      }
    },
    // 17.
    {
      question: "Select products with stock_quantity <= 150.",
      answer: "SELECT * FROM products WHERE stock_quantity <= 150;",
      result: {
        columns: ["product_id", "product_name", "category", "price", "stock_quantity"],
        rows: [
          { product_id: 1, product_name: "Lollipop", category: "Lollipop", price: 1.50, stock_quantity: 150 },
          { product_id: 4, product_name: "Hard Candy", category: "Hard Candy", price: 0.50, stock_quantity: 100 },
          { product_id: 5, product_name: "Caramel Chew", category: "Caramel", price: 1.25, stock_quantity: 75 }
        ]
      }
    },
    // 18.
    {
      question: "Select sale IDs for sales where quantity_sold >= 15.",
      answer: "SELECT sale_id FROM sales WHERE quantity_sold >= 15;",
      result: {
        columns: ["sale_id"],
        rows: [
          { sale_id: 2 },
          { sale_id: 3 },
          { sale_id: 4 },
          { sale_id: 5 }
        ]
      }
    },
    // 19.
    {
      question: "Select product names where stock_quantity >= 200.",
      answer: "SELECT product_name FROM products WHERE stock_quantity >= 200;",
      result: {
        columns: ["product_name"],
        rows: [
          { product_name: "Chocolate Bar" }
        ]
      }
    },
    // 20.
    {
      question: "Select sale dates ordered by sale_date ASC.",
      answer: "SELECT sale_date FROM sales ORDER BY sale_date ASC;",
      result: {
        columns: ["sale_date"],
        rows: [
          { sale_date: "2025-03-01" },
          { sale_date: "2025-03-02" },
          { sale_date: "2025-03-03" },
          { sale_date: "2025-03-04" },
          { sale_date: "2025-03-05" }
        ]
      }
    }
  ],
  advanced: [
    {
      question: "Find the average price of all products.",
      answer: "SELECT AVG(price) AS average_price FROM products GROUP BY 1;",
      result: {
        columns: ["average_price"],
        rows: [
          { average_price: 1.2 }
        ]
      }
    },
    {
      question: "Find the total quantity sold in sales.",
      answer: "SELECT SUM(quantity_sold) AS total_quantity FROM sales GROUP BY 1;",
      result: {
        columns: ["total_quantity"],
        rows: [
          { total_quantity: 125 }
        ]
      }
    },
    {
      question: "Find the total sales amount from all sales.",
      answer: "SELECT SUM(total_amount) AS total_sales FROM sales GROUP BY 1;",
      result: {
        columns: ["total_sales"],
        rows: [
          { total_sales: 122.5 }
        ]
      }
    },
    {
      question: "Find the candy shop with the highest rating.",
      answer: "SELECT * FROM candy_shops ORDER BY rating DESC LIMIT 1;",
      result: {
        columns: ["shop_id", "shop_name", "location", "rating"],
        rows: [
          { shop_id: 3, shop_name: "Choco Bliss", location: "Choco Land", rating: 4.9 }
        ]
      }
    },
    {
      question: "Find the candy shop with the lowest rating.",
      answer: "SELECT * FROM candy_shops ORDER BY rating ASC LIMIT 1;",
      result: {
        columns: ["shop_id", "shop_name", "location", "rating"],
        rows: [
          { shop_id: 4, shop_name: "Gummy World", location: "Gummyville", rating: 3.2 }
        ]
      }
    },
    {
      question: "Find the most expensive product.",
      answer: "SELECT * FROM products ORDER BY price DESC LIMIT 1;",
      result: {
        columns: ["product_id", "product_name", "category", "price", "stock_quantity"],
        rows: [
          { product_id: 2, product_name: "Chocolate Bar", category: "Chocolate", price: 2.00, stock_quantity: 200 }
        ]
      }
    },
    {
      question: "Find the least expensive product.",
      answer: "SELECT * FROM products ORDER BY price ASC LIMIT 1;",
      result: {
        columns: ["product_id", "product_name", "category", "price", "stock_quantity"],
        rows: [
          { product_id: 4, product_name: "Hard Candy", category: "Hard Candy", price: 0.50, stock_quantity: 100 }
        ]
      }
    },
    {
      question: "Find the average rating of candy shops.",
      answer: "SELECT AVG(rating) AS average_rating FROM candy_shops GROUP BY 1;",
      result: {
        columns: ["average_rating"],
        rows: [
          { average_rating: 4.08 }
        ]
      }
    },
    {
      question: "List products ordered by price DESC.",
      answer: "SELECT * FROM products ORDER BY price DESC;",
      result: {
        columns: ["product_id", "product_name", "category", "price", "stock_quantity"],
        rows: [
          { product_id: 2, product_name: "Chocolate Bar", category: "Chocolate", price: 2.00, stock_quantity: 200 },
          { product_id: 1, product_name: "Lollipop", category: "Lollipop", price: 1.50, stock_quantity: 150 },
          { product_id: 5, product_name: "Caramel Chew", category: "Caramel", price: 1.25, stock_quantity: 75 },
          { product_id: 3, product_name: "Gummy Bears", category: "Gummy", price: 0.75, stock_quantity: 300 },
          { product_id: 4, product_name: "Hard Candy", category: "Hard Candy", price: 0.50, stock_quantity: 100 }
        ]
      }
    },
    {
      question: "List candy shops ordered by rating DESC.",
      answer: "SELECT * FROM candy_shops ORDER BY rating DESC;",
      result: {
        columns: ["shop_id", "shop_name", "location", "rating"],
        rows: [
          { shop_id: 3, shop_name: "Choco Bliss", location: "Choco Land", rating: 4.9 },
          { shop_id: 1, shop_name: "Candy Haven", location: "Candyland", rating: 4.5 },
          { shop_id: 5, shop_name: "Sweet Shop", location: "Sweet Town", rating: 4.0 },
          { shop_id: 2, shop_name: "Sugar Delight", location: "Sugarville", rating: 3.8 },
          { shop_id: 4, shop_name: "Gummy World", location: "Gummyville", rating: 3.2 }
        ]
      }
    },
    {
      question: "Find the product with the maximum stock_quantity.",
      answer: "SELECT * FROM products ORDER BY stock_quantity DESC LIMIT 1;",
      result: {
        columns: ["product_id", "product_name", "category", "price", "stock_quantity"],
        rows: [
          { product_id: 3, product_name: "Gummy Bears", category: "Gummy", price: 0.75, stock_quantity: 300 }
        ]
      }
    },
    {
      question: "Find the product with the minimum stock_quantity.",
      answer: "SELECT * FROM products ORDER BY stock_quantity ASC LIMIT 1;",
      result: {
        columns: ["product_id", "product_name", "category", "price", "stock_quantity"],
        rows: [
          { product_id: 5, product_name: "Caramel Chew", category: "Caramel", price: 1.25, stock_quantity: 75 }
        ]
      }
    },
    {
      question: "Find the sale with the highest total_amount.",
      answer: "SELECT * FROM sales ORDER BY total_amount DESC LIMIT 1;",
      result: {
        columns: ["sale_id", "shop_id", "product_id", "sale_date", "quantity_sold", "total_amount"],
        rows: [
          { sale_id: 5, shop_id: 4, product_id: 5, sale_date: "2025-03-05", quantity_sold: 30, total_amount: 37.50 }
        ]
      }
    },
    {
      question: "Find the sale with the lowest total_amount.",
      answer: "SELECT * FROM sales ORDER BY total_amount ASC LIMIT 1;",
      result: {
        columns: ["sale_id", "shop_id", "product_id", "sale_date", "quantity_sold", "total_amount"],
        rows: [
          { sale_id: 1, shop_id: 1, product_id: 1, sale_date: "2025-03-01", quantity_sold: 10, total_amount: 15.00 }
        ]
      }
    },
    {
      question: "Select the candy shop with the second highest rating.",
      answer: "SELECT * FROM candy_shops ORDER BY rating DESC LIMIT 1 OFFSET 1;",
      result: {
        columns: ["shop_id", "shop_name", "location", "rating"],
        rows: [
          { shop_id: 1, shop_name: "Candy Haven", location: "Candyland", rating: 4.5 }
        ]
      }
    },
    {
      question: "Select the product with the second highest price.",
      answer: "SELECT * FROM products WHERE price = (SELECT MAX(price) FROM products WHERE price < (SELECT MAX(price) FROM products));",
      result: {
        columns: ["product_id", "product_name", "category", "price", "stock_quantity"],
        rows: [
          { product_id: 1, product_name: "Lollipop", category: "Lollipop", price: 1.50, stock_quantity: 150 }
        ]
      }
    },
    {
      question: "Find the product count in each category.",
      answer: "SELECT category, COUNT(*) AS count FROM products GROUP BY category;",
      result: {
        columns: ["category", "count"],
        rows: [
          { category: "Lollipop", count: 1 },
          { category: "Chocolate", count: 1 },
          { category: "Gummy", count: 1 },
          { category: "Hard Candy", count: 1 },
          { category: "Caramel", count: 1 }
        ]
      }
    },
    {
      question: "Find the total sales for each candy shop.",
      answer: "SELECT shop_id, SUM(total_amount) AS total_sales FROM sales GROUP BY shop_id;",
      result: {
        columns: ["shop_id", "total_sales"],
        rows: [
          { shop_id: 1, total_sales: 40.00 }, // 15 + 25
          { shop_id: 2, total_sales: 30.00 },
          { shop_id: 3, total_sales: 15.00 },
          { shop_id: 4, total_sales: 37.50 }
          // shop_id 5 has no sales.
        ]
      }
    }
  ]
};

    const usedQuestions = {
      easy: new Set(),
      medium: new Set(),
      advanced: new Set(),
    };

    const mockDatabase = {
      candy_shops: [
        { shop_id: 1, shop_name: "Candy Haven", location: "Candyland", rating: 4.5 },
        { shop_id: 2, shop_name: "Sugar Delight", location: "Sugarville", rating: 3.8 },
        { shop_id: 3, shop_name: "Choco Bliss", location: "Choco Land", rating: 4.9 },
        { shop_id: 4, shop_name: "Gummy World", location: "Gummyville", rating: 3.2 },
        { shop_id: 5, shop_name: "Sweet Shop", location: "Sweet Town", rating: 4.0 }
      ],
      products: [
        { product_id: 1, product_name: "Lollipop", category: "Lollipop", price: 1.50, stock_quantity: 150 },
        { product_id: 2, product_name: "Chocolate Bar", category: "Chocolate", price: 2.00, stock_quantity: 200 },
        { product_id: 3, product_name: "Gummy Bears", category: "Gummy", price: 0.75, stock_quantity: 300 },
        { product_id: 4, product_name: "Hard Candy", category: "Hard Candy", price: 0.50, stock_quantity: 100 },
        { product_id: 5, product_name: "Caramel Chew", category: "Caramel", price: 1.25, stock_quantity: 75 }
      ],
      sales: [
        { sale_id: 1, shop_id: 1, product_id: 1, sale_date: "2025-03-01", quantity_sold: 10, total_amount: 15.00 },
        { sale_id: 2, shop_id: 2, product_id: 2, sale_date: "2025-03-02", quantity_sold: 15, total_amount: 30.00 },
        { sale_id: 3, shop_id: 3, product_id: 3, sale_date: "2025-03-03", quantity_sold: 20, total_amount: 15.00 },
        { sale_id: 4, shop_id: 1, product_id: 4, sale_date: "2025-03-04", quantity_sold: 50, total_amount: 25.00 },
        { sale_id: 5, shop_id: 4, product_id: 5, sale_date: "2025-03-05", quantity_sold: 30, total_amount: 37.50 }
      ]
    };

function executeQuery(query, outerRow = null) {
  try {
    const tables = {
      'candy_shops': mockDatabase.candy_shops,
      'products': mockDatabase.products,
      'sales': mockDatabase.sales
    };

    const keywords = query.toUpperCase().match(/\b(SELECT|FROM|WHERE|JOIN|GROUP|BY|HAVING|ORDER|LIMIT|NOT|IN|AND|OR|AS|SUM|AVG|COUNT|DISTINCT|EXISTS)\b/g) || [];
    if (!keywords.includes('SELECT') || !keywords.includes('FROM')) {
      return { error: "Invalid SQL query: Missing SELECT or FROM clause." };
    }

    // Extract table name
    const fromMatch = query.match(/FROM\s+(\w+)/i);
    if (!fromMatch) return { error: "Invalid SQL query: No FROM clause." };
    const tableName = fromMatch[1];
    let result = [...(tables[tableName] || [])];

    // Handle JOIN
    const joinMatches = [];
    let remainingQuery = query;
    let joinMatch;
    while ((joinMatch = remainingQuery.match(/JOIN\s+(\w+)\s+ON\s+(.+?)(?=\s*(?:JOIN|WHERE|GROUP|HAVING|ORDER|LIMIT|$))/i))) {
      joinMatches.push(joinMatch);
      remainingQuery = remainingQuery.slice(joinMatch.index + joinMatch[0].length);
    }

    for (const joinMatch of joinMatches) {
      const joinTable = joinMatch[1];
      const joinCondition = joinMatch[2];
      const [leftCol, rightCol] = joinCondition.split('=').map(col => col.trim());
      const leftTableAlias = leftCol.split('.')[0];
      const leftColName = leftCol.split('.')[1];
      const rightTableAlias = rightCol.split('.')[0];
      const rightColName = rightCol.split('.')[1];

      result = result.flatMap(row => {
        const joinRows = tables[joinTable].filter(joinRow => {
          const leftValue = row[leftColName] !== undefined ? row[leftColName] : row[`${leftTableAlias}_${leftColName}`];
          const rightValue = joinRow[rightColName] !== undefined ? joinRow[rightColName] : joinRow[`${rightTableAlias}_${rightColName}`];
          return leftValue === rightValue;
        }).map(joinRow => {
          const newRow = { ...row };
          Object.keys(joinRow).forEach(key => {
            newRow[key] = joinRow[key];
          });
          return newRow;
        });
        return joinRows;
      });
    }

    // Handle WHERE
    const whereMatch = query.match(/WHERE\s+(.+?)(?=\s*(?:GROUP|HAVING|ORDER|LIMIT|$))/i);
    if (whereMatch) {
      const condition = whereMatch[1].trim();
      result = result.filter(row => evaluateCondition(condition, row, query, tables));
    }

    // Handle GROUP BY and aggregation
    let columns = [];
    const groupByMatch = query.match(/GROUP\s+BY\s+(.+?)(?=\s*(?:HAVING|ORDER|LIMIT|$))/i);
    if (groupByMatch) {
      const groupByCols = groupByMatch[1].split(',').map(col => col.trim().split('.').pop());
      const grouped = {};
      result.forEach(row => {
        const key = groupByCols.map(col => row[col]).join('|');
        if (!grouped[key]) grouped[key] = [];
        grouped[key].push(row);
      });
      result = Object.values(grouped).map(group => {
        const aggRow = {};
        groupByCols.forEach(col => aggRow[col] = group[0][col]);
        return aggRow;
      });

      // Compute aggregations
      const selectMatch = query.match(/SELECT\s+(.+?)(?=\s+FROM)/i);
      if (selectMatch) {
        const selectClause = selectMatch[1].split(',').map(col => col.trim());
        columns = selectClause.map(col => {
          const aliasMatch = col.match(/(.+)\s+AS\s+(\w+)/i);
          if (aliasMatch) return aliasMatch[2];
          const aggMatch = col.match(/(\w+)\((.+)\)/);
          if (aggMatch) {
            const aggFunc = aggMatch[1];
            const aggCol = aggMatch[2].split('.').pop();
            return `${aggFunc}(${aggCol})`;
          }
          return col.split('.').pop();
        });

        result = result.map((row, index) => {
          const group = Object.values(grouped).filter(g => groupByCols.every(col => g[0][col] === row[col]))[0] || [];
          const newRow = { ...row };
          selectClause.forEach((col, colIndex) => {
            const aliasMatch = col.match(/(.+)\s+AS\s+(\w+)/i);
            const colName = aliasMatch ? aliasMatch[2] : columns[colIndex];
            const aggMatch = col.match(/(\w+)\((.+)\)/);
            if (aggMatch) {
              const aggFunc = aggMatch[1].toLowerCase();
              const aggCol = aggMatch[2].split('.').pop();
              let value;
              switch (aggFunc) {
                case 'sum':
                  value = group.reduce((sum, r) => sum + (r[aggCol] || 0), 0);
                  break;
                case 'avg':
                  value = group.reduce((sum, r) => sum + (r[aggCol] || 0), 0) / group.length;
                  break;
                case 'count':
                  value = group.length;
                  break;
                case 'max':
                  value = Math.max(...group.map(r => r[aggCol] || -Infinity));
                  break;
                case 'min':
                  value = Math.min(...group.map(r => r[aggCol] || Infinity));
                  break;
              }
              newRow[colName] = value;
            }
          });
          return newRow;
        });
      }

      // Handle HAVING
      const havingMatch = query.match(/HAVING\s+(.+?)(?=\s*(?:ORDER|LIMIT|$))/i);
      if (havingMatch) {
        const havingCondition = havingMatch[1].trim();
        result = result.filter(row => evaluateCondition(havingCondition, row, query, tables));
      }
    } else {
      // Extract selected columns if no GROUP BY
      const selectMatch = query.match(/SELECT\s+(.+?)(?=\s+FROM)/i);
      if (selectMatch) {
        columns = selectMatch[1].split(',').map(col => {
          const aliasMatch = col.match(/(.+)\s+AS\s+(\w+)/i);
          if (aliasMatch) return aliasMatch[2];
          const aggMatch = col.match(/(\w+)\((.+)\)/);
          if (aggMatch) return `${aggMatch[1]}(${aggMatch[2].split('.').pop()})`;
          return col.trim().split('.').pop() || '*';
        });
      }
      if (columns.includes('*') || columns.length === 0) {
        columns = Object.keys(result[0] || mockDatabase[tableName][0] || {});
      } else {
        result = result.map(row => {
          const newRow = {};
          columns.forEach(col => {
            const originalCol = Object.keys(row).find(key => key === col || row[key] === row[col]);
            newRow[col] = row[originalCol || col];
          });
          return newRow;
        });
      }
    }

    // Handle ORDER BY
    const orderByMatch = query.match(/ORDER\s+BY\s+(.+?)(?=\s*(?:LIMIT|$))/i);
    if (orderByMatch) {
      const orderByCols = orderByMatch[1].split(',').map(col => {
        const [colName, dir] = col.trim().split(/\s+/);
        const cleanCol = colName.match(/(\w+)\((.+)\)/) ? colName : colName.split('.').pop();
        return { col: cleanCol, dir: dir ? dir.toUpperCase() : 'ASC' };
      });
      result.sort((a, b) => {
        for (let { col, dir } of orderByCols) {
          const aVal = a[col];
          const bVal = b[col];
          if (aVal < bVal) return dir === 'ASC' ? -1 : 1;
          if (aVal > bVal) return dir === 'ASC' ? 1 : -1;
        }
        return 0;
      });
    }

    // Handle LIMIT
    const limitMatch = query.match(/LIMIT\s+(\d+)/i);
    if (limitMatch) {
      const limit = parseInt(limitMatch[1]);
      result = result.slice(0, limit);
    }

    return { columns, rows: result };
  } catch (e) {
    return { error: `Query execution failed: ${e.message}` };
  }
}

// Helper function to evaluate WHERE and HAVING conditions
function evaluateCondition(condition, row, query, tables) {
  try {
    // Handle subqueries
    if (condition.toUpperCase().includes('NOT EXISTS') || condition.toUpperCase().includes('IN')) {
      return evaluateSubqueryCondition(condition, row, query, tables);
    }

    // Handle subquery in HAVING (e.g., total_sold = (SELECT ...))
    const subqueryMatch = condition.match(/(\w+)\s*=\s*\((SELECT\s+.+?)\)/i);
    if (subqueryMatch) {
      const leftCol = subqueryMatch[1];
      const subquery = subqueryMatch[2];
      // Pass the outer row to the subquery for proper correlation
      const subResult = executeQuery(subquery, row);
      if (subResult.error) return false;
      const subValue = subResult.rows[0] ? subResult.rows[0][subResult.columns[0]] : null;
      return row[leftCol] === subValue;
    }

    // Split condition on AND/OR
    const andConditions = condition.split(/\s+AND\s+/i);
    if (andConditions.length > 1) {
      return andConditions.every(subCondition => evaluateCondition(subCondition.trim(), row, query, tables));
    }

    const orConditions = condition.split(/\s+OR\s+/i);
    if (orConditions.length > 1) {
      return orConditions.some(subCondition => evaluateCondition(subCondition.trim(), row, query, tables));
    }

    // Handle simple condition
    return evaluateSimpleCondition(condition, row);
  } catch (e) {
    console.error("Condition evaluation error:", e);
    return false;
  }
}

// Evaluate a simple condition (e.g., price < 5, sale_date = '2025-03-01')
function evaluateSimpleCondition(condition, row) {
  const match = condition.match(/(\w+)\s*(=|<|>|>=|<=)\s*('[^']*'|\d+\.?\d*)/i);
  if (!match) {
    const likeMatch = condition.match(/(\w+)\s+LIKE\s+('[^']*')/i);
    if (likeMatch) {
      const [, column, pattern] = likeMatch;
      const value = row[column];
      const regexPattern = pattern.slice(1, -1).replace(/%/g, '.*').replace(/_/g, '.');
      const regex = new RegExp(`^${regexPattern}$`, 'i');
      return typeof value === 'string' && regex.test(value);
    }
    return false;
  }

  const [, column, operator, rawValue] = match;
  const value = rawValue.startsWith("'") ? rawValue.slice(1, -1) : parseFloat(rawValue);
  const rowValue = row[column];

  switch (operator) {
    case '=':
      return rowValue === value;
    case '<':
      return typeof rowValue === 'number' && typeof value === 'number' && rowValue < value;
    case '>':
      return typeof rowValue === 'number' && typeof value === 'number' && rowValue > value;
    case '>=':
      return typeof rowValue === 'number' && typeof value === 'number' && rowValue >= value;
    case '<=':
      return typeof rowValue === 'number' && typeof value === 'number' && rowValue <= value;
    default:
      return false;
  }
}

// Evaluate conditions with subqueries
function evaluateSubqueryCondition(condition, row, query, tables) {
  // Handle NOT EXISTS
  const notExistsMatch = condition.match(/NOT EXISTS\s*\((SELECT\s+.+?)\)/i);
  if (notExistsMatch) {
    const subquery = notExistsMatch[1];
    // Execute the subquery with the outer row context
    const subResult = executeQuery(subquery, row);
    if (subResult.error) return false;
    return subResult.rows.length === 0;
  }

  // Handle IN and NOT IN
  const inMatch = condition.match(/(\w+)\s+(NOT\s+)?IN\s*\((SELECT\s+.+?)\)/i);
  if (inMatch) {
    const [, column, notModifier, subquery] = inMatch;
    const subResult = executeQuery(subquery, row);
    if (subResult.error) return false;
    const values = subResult.rows.map(r => r[subResult.columns[0]]);
    const isIn = values.includes(row[column]);
    return notModifier ? !isIn : isIn;
  }

  return false;
}

function deepEqual(a, b) {
  if (a === b) return true;

  if (typeof a !== 'object' || typeof b !== 'object' || a === null || b === null) {
    return false;
  }

  if (Array.isArray(a) !== Array.isArray(b)) return false;

  if (Array.isArray(a)) {
    if (a.length !== b.length) return false;
    // Convert each item to a JSON string and sort for comparison
    const sortedA = a.map(item => JSON.stringify(item)).sort();
    const sortedB = b.map(item => JSON.stringify(item)).sort();
    return sortedA.every((val, idx) => val === sortedB[idx]);
  }

  // For objects, compare keys (sorted) and values recursively.
  const keysA = Object.keys(a).sort();
  const keysB = Object.keys(b).sort();
  if (!deepEqual(keysA, keysB)) return false;

  return keysA.every(key => deepEqual(a[key], b[key]));
}

    window.onload = () => {
      generateTilePositions();
      generateTiles();
      startTime = Date.now();
      timeInterval = setInterval(updateTimer, 1000);
      loadScoreboard();
      setupSyntaxHighlighting();
      updateProgress();
      window.addEventListener('resize', () => {
        generateTilePositions();
        placePlayer();
      });
      document.getElementById('tiles-container').addEventListener('touchstart', handleTouchStart);
      document.getElementById('tiles-container').addEventListener('touchmove', handleTouchMove);
      document.getElementById('tiles-container').addEventListener('touchend', handleTouchEnd);
    };

    let touchStartX = 0;
    let touchStartY = 0;

    function handleTouchStart(e) {
      touchStartX = e.touches[0].clientX;
      touchStartY = e.touches[0].clientY;
    }

    function handleTouchMove(e) {
      e.preventDefault();
    }

    function handleTouchEnd(e) {
      const touchEndX = e.changedTouches[0].clientX;
      const touchEndY = e.changedTouches[0].clientY;
      const deltaX = touchEndX - touchStartX;
      const deltaY = touchEndY - touchStartY;
      if (Math.abs(deltaX) > Math.abs(deltaY) && Math.abs(deltaX) > 50) {
        if (deltaX > 0 && playerPosition < totalSpaces - 1) {
          getQuestion('easy');
        }
      }
    }

    function generateTilePositions() {
      tilePositions = [];
      const board = document.querySelector('.board');
      const tilesContainer = document.getElementById('tiles-container');
      const boardRect = board.getBoundingClientRect();
      const tileElements = tilesContainer.children;
      if (tileElements.length === 0) return;
      for (let i = 0; i < totalSpaces; i++) {
        const tileRect = tileElements[i].getBoundingClientRect();
        const x = tileRect.left - boardRect.left + (tileRect.width - tileRect.width * 0.8) / 2;
        const y = tileRect.top - boardRect.top + (tileRect.height - tileRect.height * 0.8) / 2;
        tilePositions.push([x, y]);
      }
    }

    function generateTiles() {
      const container = document.getElementById("tiles-container");
      container.innerHTML = "";
      stickyTiles.clear();
      for (let i = 0; i < totalSpaces; i++) {
        const tile = document.createElement("div");
        tile.classList.add("tile");
        tile.style.background = pastelColors[Math.floor(Math.random() * pastelColors.length)];
        if (i === 0) {
          tile.classList.add("start-tile");
          tile.innerText = "Start";
        } else if (i === totalSpaces - 1) {
          tile.style.background = "#FFFACD";
          tile.innerHTML = `<span class="castle-icon">üè∞</span>`;
        } else {
          if (Math.random() < 0.2 && i !== 0 && i !== totalSpaces - 1) {
            tile.classList.add("sticky-tile");
            tile.innerText = "üçØ";
            stickyTiles.add(i);
          } else {
            tile.innerText = candyIcons[Math.floor(Math.random() * candyIcons.length)];
          }
        }
        container.appendChild(tile);
      }
      setTimeout(() => {
        generateTilePositions();
        placePlayer();
      }, 0);
    }

    function resetPlayer() {
      playerPosition = 0;
      hintsLeft = 3;
      moveCount = 0;
      stickyAnswersNeeded = 0;
      startTime = Date.now();
      if (timeInterval) clearInterval(timeInterval);
      timeInterval = setInterval(updateTimer, 1000);
      document.getElementById("hints-left").innerText = `Hints Left: ${hintsLeft}`;
      document.getElementById("time-display").innerText = "Time Elapsed: 0m 0s";
      placePlayer();
      closePopup();
      closeMessagePopup();
      updateProgress();
      usedQuestions.easy.clear();
      usedQuestions.medium.clear();
      usedQuestions.advanced.clear();
    }

    function placePlayer() {
      const player = document.getElementById("player");
      const tiles = document.querySelectorAll(".tile");
      tiles.forEach((tile, index) => {
        tile.classList.toggle("active-tile", index === playerPosition);
      });
      if (tilePositions[playerPosition]) {
        const [x, y] = tilePositions[playerPosition];
        player.style.left = x + "px";
        player.style.top = y + "px";
        player.classList.remove("move");
        void player.offsetWidth;
        player.classList.add("move");
      }
      updateProgress();
    }

    function updateProgress() {
      const progress = (playerPosition / (totalSpaces - 1)) * 100;
      document.getElementById("progress").style.width = `${progress}%`;
    }

    function selectCharacter(icon) {
      playerIcon = icon;
      document.getElementById("player").innerText = icon;
      placePlayer();
    }

    function movePlayer(spaces) {
      moveCount++;
      const newPosition = Math.min(playerPosition + spaces, totalSpaces - 1);
      playerPosition = newPosition;
      placePlayer();
      if (playerPosition === totalSpaces - 1) {
        document.getElementById("win-sound").play();
        showFinalPopup();
      } else if (stickyTiles.has(playerPosition)) {
        document.getElementById("sticky-sound").play();
        if (stickyAnswersNeeded === 0) {
          stickyAnswersNeeded = 2;
          showMessage("You are stuck on a sticky honey tile. You must answer two questions correctly to proceed.");
          setTimeout(() => getQuestion(currentDifficulty), 1000);
        }
      }
      confetti({
        particleCount: 100,
        spread: 70,
        origin: { y: 0.6 }
      });
    }

    function updateTimer() {
      const elapsedSec = Math.floor((Date.now() - startTime) / 1000);
      const minutes = Math.floor(elapsedSec / 60);
      const seconds = elapsedSec % 60;
      document.getElementById("time-display").innerText = `Time Elapsed: ${minutes}m ${seconds}s`;
    }

    function loadScoreboard() {
      const saved = localStorage.getItem("scoreboard");
      if (saved) {
        scoreboard.push(...JSON.parse(saved));
        updateScoreboardDisplay();
      }
    }

    function saveScoreboard() {
      localStorage.setItem("scoreboard", JSON.stringify(scoreboard));
    }

    function updateScoreboard(playerName) {
      const elapsedSec = Math.floor((Date.now() - startTime) / 1000);
      const score = { name: playerName, time: elapsedSec, moves: moveCount };
      scoreboard.push(score);
      scoreboard.sort((a, b) => a.time - b.time);
      if (scoreboard.length > 10) scoreboard.pop();
      updateScoreboardDisplay();
      saveScoreboard();
    }

    function updateScoreboardDisplay() {
      const list = document.getElementById("score-list");
      list.innerHTML = "";
      scoreboard.forEach((entry, index) => {
        const li = document.createElement("li");
        li.innerText = `${index + 1}. ${entry.name} - ${Math.floor(entry.time / 60)}m ${entry.time % 60}s (${entry.moves} moves)`;
        list.appendChild(li);
      });
    }

    function getQuestion(difficulty) {
      if (playerPosition >= totalSpaces - 1) {
        showMessage("You have already reached the Candy Castle!");
        return;
      }

      currentDifficulty = difficulty;
      spacesToMove = difficulty === 'easy' ? 1 : difficulty === 'medium' ? 2 : 3;

      const pool = sqlQuestions[difficulty];
      const used = usedQuestions[difficulty];
      const available = pool.filter((q, idx) => !used.has(idx));
      if (available.length === 0) {
        used.clear();
        showMessage("All questions for this difficulty have been used. Resetting question pool.");
      }
      const updatedAvailable = pool.filter((q, idx) => !used.has(idx));
      if (updatedAvailable.length === 0) {
        showMessage("Error: No questions available after reset.");
        return;
      }
      const randIndex = Math.floor(Math.random() * updatedAvailable.length);
      currentQuestion = updatedAvailable[randIndex];
      const originalIndex = pool.indexOf(currentQuestion);
      used.add(originalIndex);

      document.getElementById("question-text").innerText = currentQuestion.question;
      const answerDiv = document.getElementById("answer");
      answerDiv.innerHTML = "";
      answerDiv.focus();
      document.getElementById("question-popup").style.display = "block";
    }

    function setupSyntaxHighlighting() {
      const answerDiv = document.getElementById("answer");
      answerDiv.addEventListener("input", function() {
        const text = this.innerText;
        const highlighted = text
          .replace(/\b(SELECT|FROM|WHERE|JOIN|GROUP|BY|HAVING|ORDER|LIMIT|NOT|IN|AND|OR|AS|SUM|AVG|COUNT|DISTINCT)\b/gi, '<span class="sql-keyword">$1</span>')
          .replace(/'[^']*'/gi, '<span class="sql-string">$&</span>')
          .replace(/\b\d+(\.\d+)?\b/gi, '<span class="sql-number">$&</span>');
        this.innerHTML = highlighted;
        const range = document.createRange();
        const sel = window.getSelection();
        range.selectNodeContents(this);
        range.collapse(false);
        sel.removeAllRanges();
        sel.addRange(range);
      });
    }

    function submitAnswer() {
      if (!currentQuestion) {
        showMessage("Please select a question first.");
        return;
      }
      const answerDiv = document.getElementById("answer");
      const userQuery = answerDiv.innerText.trim();
      const correctResult = currentQuestion.result;
      const userResult = executeQuery(userQuery);

      if (userResult.error) {
        showMessage(`Error: ${userResult.error}`);
        return;
      }

      // Display user result and expected result for debugging
      let message = `Your Query: ${userQuery}\nYour Result:\n`;
      message += `Columns: ${JSON.stringify(userResult.columns)}\nRows: ${JSON.stringify(userResult.rows)}\n\n`;
      message += `Expected Result:\nColumns: ${JSON.stringify(correctResult.columns)}\nRows: ${JSON.stringify(correctResult.rows)}`;

      const isCorrect = deepEqual(userResult, correctResult);
      if (isCorrect) {
        closePopup();
        if (stickyAnswersNeeded > 0) {
          stickyAnswersNeeded--;
          if (stickyAnswersNeeded > 0) {
            showMessage(`Correct! One more correct answer is required to pass the sticky honey tile. (${stickyAnswersNeeded} left)\n\n${message}`);
            setTimeout(() => getQuestion(currentDifficulty), 1000);
          } else {
            showMessage("Correct! You have cleared the sticky honey tile. You may proceed on your next turn.\n\n" + message);
          }
        } else {
          movePlayer(spacesToMove);
          showMessage(`Correct! You moved forward ${spacesToMove} space(s)!\n\n${message}`);
        }
      } else {
        showMessage(`Incorrect answer. Try again or use a hint!\n\n${message}`);
      }
    }

    function showHint() {
      if (hintsLeft <= 0) {
        showMessage("No hints left!");
        return;
      }
      if (!currentQuestion) {
        showMessage("There is no active question to show a hint for.");
        return;
      }
      hintsLeft--;
      const hintText = currentQuestion.answer.split(" ").slice(0, Math.floor(currentQuestion.answer.split(" ").length / 2)).join(" ") + " ...";
      showMessage(`Hint: ${hintText}\nHints Left: ${hintsLeft}`);
      document.getElementById("hints-left").innerText = `Hints Left: ${hintsLeft}`;
    }

    function showDatabaseSchema() {
      showMessage(
        "candy_shops\n" +
        "  shop_id: INT PRIMARY KEY\n" +
        "  shop_name: VARCHAR(100) NOT NULL\n" +
        "  location: VARCHAR(100)\n" +
        "  rating: DECIMAL(2,1) CHECK (rating >= 0 AND rating <= 5)\n\n" +
        "products\n" +
        "  product_id: INT PRIMARY KEY\n" +
        "  product_name: VARCHAR(100) NOT NULL\n" +
        "  category: VARCHAR(50)\n" +
        "  price: DECIMAL(10,2)\n" +
        "  stock_quantity: INT\n\n" +
        "sales\n" +
        "  sale_id: INT PRIMARY KEY\n" +
        "  shop_id: INT\n" +
        "  product_id: INT\n" +
        "  sale_date: DATE\n" +
        "  quantity_sold: INT\n" +
        "  total_amount: DECIMAL(10,2)\n" +
        "  FOREIGN KEY (shop_id) REFERENCES candy_shops(shop_id)\n" +
        "  FOREIGN KEY (product_id) REFERENCES products(product_id)"
      );
    }

    function showAnswer() {
      if (!currentQuestion) {
        showMessage("There is no active question to show the answer for.");
        return;
      }
      showMessage(`The correct answer is:\n${currentQuestion.answer}`);
      closePopup();
      setTimeout(() => getQuestion(currentDifficulty), 1000);
    }

    function showMessage(message) {
      const popup = document.getElementById("message-popup");
      const messageText = document.getElementById("message-text");
      messageText.innerHTML = '<pre style="white-space: pre-wrap;">' + message + '</pre>';
      popup.style.display = "block";
    }

    function closePopup() {
      document.getElementById("question-popup").style.display = "none";
      currentQuestion = null;
    }

    function closeMessagePopup() {
      document.getElementById("message-popup").style.display = "none";
    }

    function showFinalPopup() {
      const elapsedSec = Math.floor((Date.now() - startTime) / 1000);
      const minutes = Math.floor(elapsedSec / 60);
      const seconds = elapsedSec % 60;
      document.getElementById("final-message").innerText = `Congratulations! You reached the Candy Castle in ${minutes}m ${seconds}s with ${moveCount} moves!`;
      document.getElementById("final-popup").style.display = "block";
      confetti({
        particleCount: 100,
        spread: 70,
        origin: { y: 0.6 }
      });
      clearInterval(timeInterval);
    }

    function closeFinalPopup() {
      document.getElementById("final-popup").style.display = "none";
    }

    function submitFinalScore() {
      const playerName = document.getElementById("player-name").value.trim();
      if (playerName) {
        updateScoreboard(playerName);
        closeFinalPopup();
        resetPlayer();
      } else {
        showMessage("Please enter your name!");
      }
    }
  </script>
</body>
</html>